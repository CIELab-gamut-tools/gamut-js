import{mult as t,from as e,rows as a,diag as n,mapMany as r,div as o,grid as s,reshape as l,zeros as i,mcat as p,min as f,max as c,cross as g,sum as h,product as m,vcat as u,cumsum as w,gridInterp1 as d}from"t-matrix";function A(t){const e=(t=[...t]).length;let[a,n]=s(t,t);a=l(a,e*e,1),n=l(n,e*e,1);const r=i(e*e,1).set(t[0]),o=i(e*e,1).set(t[e-1]),f=p([[r,a,n],[n,r,a],[a,n,r],[o,n,a],[a,o,n],[n,a,o]]),c=i(12*(e-1)*(e-1),3);let g=0;for(let t=0;t<6;t++)for(let a=0;a<e-1;a++)for(let n=0;n<e-1;n++){let r=e*e*t+e*a+n;c.set([g,g+1],":",[[r,r+e,r+1],[r+e,r+e+1,r+1]]),g+=2}return[c,f]}function M(t,n){const r=e([...a(t)].map(([t,e])=>[t/e,1,(1-t-e)/e]));return n?product(r,n):r}function y(t){const e={},a=function*(t){if(null!=t){"string"!=typeof t&&"function"==typeof t[Symbol.iterator]||(t=[t]);for(let e of t)if("string"==typeof e)for(let t of e.match(/[^\r\n]+/g))yield t.split("#")[0]}}(t)[Symbol.iterator]();let n,r,o,s,l;const p=()=>(n=a.next()).done;for(;!p();){const[t,...a]=n.value.split(/\s+/);if(/^CGATS/.test(t))e.version=t;else switch(t){case"BEGIN_DATA_FORMAT":for(o=[];!p()&&"END_DATA_FORMAT"!==n.value;)o.push(...n.value.toUpperCase().split(/\s+/));break;case"NUMBER_OF_SETS":r=Number.parseInt(a[0]);break;case"BEGIN_DATA":if(!r||!o)throw new Error("readCGATS: NUMBER_OF_SETS and *_DATA_FORMAT required before BEGIN_DATA");s=i(r,o.length),l=0;let f=o.indexOf("SAMPLEID");for(-1===f&&(f=o.indexOf("SAMPLE_ID")),-1===f&&(f=o.indexOf("SAMPLE_NO"));!p()&&"END_DATA"!==n.value;){const t=n.value.split(/\s+/).map(Number.parseFloat);if(f>=0){if(l=t[f],l<1||l>r)throw new Error("readCGATS: SampleID outside the range 1..NUMBER_OF_SETS");s.set(l-1,":",[t])}else s.set(l++-1,":",[t])}if(l!==r)throw new Error("readCGATS: data rows does not match NUMBER_OF_SETS");e.format={};for(let t=0;t<o.length;t++)e.format[o[t]]=t;e.data=s;break;default:e[t]=a.join(" ")}}return e}function R(t,e){const a=y(t),n=["RGB_R","RGB_G","RGB_B"],r=["XYZ_X","XYZ_Y","XYZ_Z"];for(let t of[...n,...r])if(!a.format.hasOwnProperty(t))throw new Error("GAMUT:: Cgats file must have the following data - "+PROPS.join(", "));return a.RGB=a.data.get(":",n.map(t=>a.format[t])),a.XYZ=a.data.get(":",r.map(t=>a.format[t])),Object.assign(a,e),B(a)}function B(t){t.gsv=[...new Set(t.RGB)].sort((t,e)=>t-e);const[e,a]=A(t.gsv),n=function(t,e,a){const n=new Map(a.map((t,e)=>[t,e])),r=a.length,o=([t,e,a])=>n.get(t)+r*(n.get(e)+r*n.get(a)),s=new Map(e.toJSON().map((t,e)=>[o(t),e]));return t.toJSON().map(t=>s.get(o(t)))}(a,t.RGB,t.gsv);if(n.indexOf(void 0)>=0)throw new Error("GAMUT:: Missing RGB data");return t.TRI=e.map(t=>n[t]),G(t)}function G(s){return s.RGBmax=s.gsv[s.gsv.length-1],s.XYZn=s.XYZ.get([...f(s.RGB,null,2)].indexOf(s.RGBmax),":"),s.caXYZn||(s.caXYZn=e([[.9642957,1,.8251046]])),s.caXYZ=function(a,s,l){const i=e([[.8951,.2664,-.1614],[-.7502,1.7135,.0367],[.0389,-.0685,1.0296]]).t,p=t(s,i),f=t(l,i),c=n(r(f,p,(t,e)=>t/e).t),g=o(t(i,c),i);return t(a,g)}(s.XYZ,s.XYZn,s.caXYZn),s.LAB=function(t,n){const o=r(t,n,(t,e)=>t/e).map(t=>t<=216/24389?t*(24389/3132)+16/116:Math.pow(t,1/3));return e([...a(o)].map(([t,e,a])=>[116*e-16,500*(t-e),200*(e-a)]))}(s.caXYZ,s.caXYZn),S(s)}function _(t){t.Lsteps||(t.Lsteps=100),t.hsteps||(t.hsteps=360);const{TRI:a,LAB:n,Lsteps:o,hsteps:s}=t,l=n.get(":",[1,2,0]),i=c(l.get([...a.get(":",0)],2),l.get([...a.get(":",1)],2),l.get([...a.get(":",2)],2)),p=f(l.get([...a.get(":",0)],2),l.get([...a.get(":",1)],2),l.get([...a.get(":",2)],2)),u=2*Math.PI/s,w=new Array(o);for(let t=0;t<o;t++){let n=100*(t+.5)/o,f=e([[0,0,n]]),c=(d=r(p,i,(t,e)=>t<=n&&n<e),[...d].map((t,e)=>[t,e]).filter(t=>t[0]).map(t=>t[1])),A=l.get([...a.get(c,0)],":"),M=l.get([...a.get(c,1)],":"),y=l.get([...a.get(c,2)],":"),R=r(M,A,(t,e)=>t-e),B=r(y,A,(t,e)=>t-e),G=r(f,A,(t,e)=>t-e),_=g(B,R,2),S=g(B,G,2),E=g(G,R,2);w[t]=T([..._.get(":",[0,1])],[...S.get(":",[0,1])],[...E.get(":",[0,1])],[...h(m(B,E),null,2)],s,u)}var d;return t.cylmap=w,t}function S(t){t.Lsteps||(t.Lsteps=100),t.hsteps||(t.hsteps=360);const{TRI:e,LAB:a,Lsteps:n,hsteps:r}=t,o=new Uint32Array(e),s=new Float64Array(a),l=o.length/3,i=new Float64Array(l),p=new Float64Array(l);for(let t=0,e=0;e<l;e++){const a=s[3*o[t++]],n=s[3*o[t++]],r=s[3*o[t++]];a>n?n>r?(p[e]=r,i[e]=a):(p[e]=n,i[e]=a>r?a:r):n>r?(p[e]=a>r?r:a,i[e]=n):(p[e]=a,i[e]=r),i[e]=Math.max(a,n,r),p[e]=Math.min(a,n,r)}const f=2*Math.PI/r,c=new Array(n);for(let t=0;t<n;t++){const e=100*(t+.5)/n,a=[];for(let t=0;t<l;t++)p[t]<=e&&e<i[t]&&a.push(t);const g=a.length,h=new Float64Array(2*g),m=new Float64Array(2*g),u=new Float64Array(2*g),w=new Float64Array(g);for(let t=0,n=0;t<g;t++,n+=2){const r=3*a[t],l=3*o[r],i=3*o[r+1],p=3*o[r+2],f=s[l],c=s[l+1],g=s[l+2],d=s[i]-f,A=s[i+1]-c,M=s[i+2]-g,y=s[p]-f,R=s[p+1]-c,B=s[p+2]-g,G=e-f,_=-c,S=-g;h[n]=B*d-y*M,h[n+1]=A*y-R*d,m[n]=B*G-y*S,m[n+1]=_*y-R*G,u[n]=S*d-G*M,u[n+1]=A*G-_*d,w[t]=R*u[n]+B*u[n+1]+y*(_*M-A*S)}c[t]=T(h,m,u,w,r,f)}return t.cylmap=c,t}function T(t,e,a,n,r,o){const s=n.length,l=new Array(r);for(let i=0;i<r;i++){const r=[],p=(i+.5)*o,f=Math.sin(p),c=Math.cos(p);let g,h,m,u;for(let o=0,l=0;o<s;o++,l+=2)g=1/(f*t[l]+c*t[l+1]),(u=g*n[o])>0&&(h=g*(f*e[l]+c*e[l+1]))>=0&&(m=g*(f*a[l]+c*a[l+1]))>=0&&h+m<=1&&r.push([Math.sign(g),u]);l[i]=r}return l}function E(t){let e=2*Math.PI/t.hsteps,a=100/t.Lsteps,n=0;for(let e=0;e<t.Lsteps;e++)for(let a=0;a<t.hsteps;a++){const r=t.cylmap[e][a];for(let t=0;t<r.length;t++)n+=r[t][0]*r[t][1]*r[t][1]}return n*a*e/2}function O(t,a){const n=2*Math.PI/t.hsteps,r=100/t.Lsteps*n/2,o=e(t.cylmap.map(t=>t.map(t=>{let e=0;for(let a of t)e+=a[0]*a[1]*a[1]*r;return e}))),s=u(i(1,t.hsteps),w(o).map(t=>Math.pow(2*t/n,.5))),l=d(s,a),p=e([[n/2,"::",n,2*Math.PI]]);return[m(p.map(Math.sin),l),m(p.map(Math.cos),l),l,h(o)]}const x={d50:[.3457,.3585],d55:[.3324,.3474],d60:[.32168,.33767],d65:[.3127,.329],d75:[.299,.3149]},b={default:{driveMapping:t=>t,gamma:2.4,black:null,blackRatio:0,steps:10,white:"d65",RGBxy:[[.64,.33],[.3,.6],[.15,.06]]},srgb:{white:"d65",RGBxy:[[.64,.33],[.3,.6],[.15,.06]],gamma:t=>t>.04045?Math.pow((200*t+11)/211,2.4):25*t/323},"bt.2020":{white:"d65",RGBxy:[[.708,.292],[.17,.797],[.131,.046]],gamma:2.4},"dci-p3":{white:[.314,.351],RGBxy:[[.68,.32],[.265,.69],[.15,.06]],gamma:2.4},"d65-p3":{white:"d65",RGBxy:[[.68,.32],[.265,.69],[.15,.06]],gamma:2.4},"d50-p3":{white:"d50",RGBxy:[[.68,.32],[.265,.69],[.15,.06]],gamma:2.4}};function v(n,r){r="string"==typeof n?Object.assign({},b.default,b[n.toLowerCase()],r):Object.assign({},b.default,n);let{white:s,RGBxy:l,gamma:p,black:f,blackRatio:c,steps:g,colorantXYZ:w,driveMapping:d}=r,y="function"==typeof p?p:t=>Math.pow(t,p),R=e([d([1,1,1])]);if(w)w=e(w);else{for(;"string"==typeof s;)s=x[s]||b[s].white;s=e([s]);let t=M(s),a=M(e(l)),n=o(t,a);w=m(a,n.t),R.length>3&&(w=u([w,t]))}let G=t(R,w),_=i(1,3);if(c){if(f)for(;"string"==typeof f;)f=x[f]||b[f].white;else f=s;_=M(f,G.get(0,1)/(1/c-1))}let S=A(e([0,":",g]))[1];const T=g+1;S=e([...new Map([...a(S)].map(([t,e,a])=>[t+T*(e+T*a),[t,e,a]])).values()]),S=S.map(t=>t/g);let E=S.map(y),O=e([...a(E)].map(d));return B({RGB:S,XYZ:h(t(O,w),_)})}export{_ as _fromTRILAB,R as fromCgats,S as fromTRILAB,G as fromTRIXYZ,B as fromXYZ,E as gamutVolume,v as makeSynthetic,O as rings};
